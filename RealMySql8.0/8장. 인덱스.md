# 8.0 INTRO
- MySql 8.0 부터는 전문 검색이나 위치 기반 검색 기능도 InnoDB 스토리지 엔진에서 사용할 수 있도록 개선되었다.
- 인덱스는 쿼리 튜닝의 기본이다.

# 8.1 디스크 읽기 방식
- 데이터베이스 성능 튜닝은 어떻게 디스크 IO를 줄이느냐가 관건이다.
- SSD는 하드디스크보다 약 500배 정도 빠르며, 메모리는 SSD보다 1000배 더 빠르다.
    - 따라서 SSD가 빨라도, 디스크 IO를 줄여야 데이터베이스의 성능이 개선된다.
- SSD의 랜덤 IO 성능이 하드디스크의 그것보다 빠르다고 해서, SSD의 랜덤 IO는 순차 IO 보다 느리다.
- 쿼리를 튜닝한다고 해서 랜덤 IO를 순차 IO로 바꾸긴 어려우므로, 꼭 필요한 데이터만 읽도록 쿼리를 튜닝해야 한다.
- 풀 테이블 스캔은 인덱스와 달리 순차 IO를 사용하므로 레코드 대부분을 읽는 작업은 풀 테이블 스캔이 유리하다.

# 8.2 인덱스란?
- 인덱스는 색인에 비유된다.
- 인덱스는 특정 칼럼 (칼럼들)의 값을 기준으로 정렬된 구조를 유지하며, 그 값을 가지고 있는 주소도 같이 가지고 있다.
- 인덱스는 항상 값이 정렬된 상태를 유지해야 하므로 데이터 변경 비용이 비싸지만, 조회 시에는 빠르게 데이터를 가져올 수 있다.
    - 따라서 적절하게 인덱스를 설정하는 것이 중요하다.
- 인덱스는 프라이머리키와 세컨더리 인덱스로 나뉜다.
    - InnoDB에서 세컨더리 인덱스는 클러스터링 인덱스 기능으로 인해, 프라이머리 키의 주소를 참조한다.
- 일반적으로 인덱스는 B-Tree 알고리즘이 사용된다.

# 8.3 B-Tree 인덱스
- Balanced Tree 의 약자이다.
- 데이터를 항상 정렬된 상태로 유지하며, 일반적인 용도에 적합한 알고리즘이다.
- 루트노드, 브랜치 노드, 리프 노드로 구성된다. 리프 노드엔 값과 참조값이 들어있으면 루트 노드와 브랜치 노드는 리프 노드를 찾기 위한 용도로 사용된다.
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
- 인덱스 키 추가는 밸런싱 비용때문에 비싸다.
    - 테이블에 레코드를 추가하는 비용이 1이라면,
    - 하나의 인덱스 변경에는 1.5 정도의 비용이 들어가며
    - 세 개의 인덱스를 가지고 있는 테이블을 변경하기 위해서는 5.5 정도의 비용이 들어간다고 예측한다.
    - 인덱스 변경 비용의 대부분은 디스크 IO 이다.
    - 프라이머리 키이거나 유니크 인덱스가 아닌 경우 체인지 버퍼를 이용해 인덱스 변경 작업을 지연시킬 수 있다.
- 인덱스 키 삭제는 삭제 마크만 해두고, 실제 삭제는 백그라운드에서 처리한다.
- 인덱스 키 변경은 삭제 후 추가하는 방식으로 이루어진다.
- Update 나 Delete 시 인덱스를 잠근 후 테이블을 잠그는 방식으로 실행되기 때문에, 적절한 레코드가 없다면 불필요하게 많을 레코드를 잠근다.