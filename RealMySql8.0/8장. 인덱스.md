# 8.0 INTRO
- MySql 8.0 부터는 전문 검색이나 위치 기반 검색 기능도 InnoDB 스토리지 엔진에서 사용할 수 있도록 개선되었다.
- 인덱스는 쿼리 튜닝의 기본이다.

# 8.1 디스크 읽기 방식
- 데이터베이스 성능 튜닝은 어떻게 디스크 IO를 줄이느냐가 관건이다.
- SSD는 하드디스크보다 약 500배 정도 빠르며, 메모리는 SSD보다 1000배 더 빠르다.
    - 따라서 SSD가 빨라도, 디스크 IO를 줄여야 데이터베이스의 성능이 개선된다.
- SSD의 랜덤 IO 성능이 하드디스크의 그것보다 빠르다고 해서, SSD의 랜덤 IO는 순차 IO 보다 느리다.
- 쿼리를 튜닝한다고 해서 랜덤 IO를 순차 IO로 바꾸긴 어려우므로, 꼭 필요한 데이터만 읽도록 쿼리를 튜닝해야 한다.
- 풀 테이블 스캔은 인덱스와 달리 순차 IO를 사용하므로 레코드 대부분을 읽는 작업은 풀 테이블 스캔이 유리하다.

# 8.2 인덱스란?
- 인덱스는 색인에 비유된다.
- 인덱스는 특정 칼럼 (칼럼들)의 값을 기준으로 정렬된 구조를 유지하며, 그 값을 가지고 있는 주소도 같이 가지고 있다.
- 인덱스는 항상 값이 정렬된 상태를 유지해야 하므로 데이터 변경 비용이 비싸지만, 조회 시에는 빠르게 데이터를 가져올 수 있다.
    - 따라서 적절하게 인덱스를 설정하는 것이 중요하다.
- 인덱스는 프라이머리키와 세컨더리 인덱스로 나뉜다.
    - InnoDB에서 세컨더리 인덱스는 클러스터링 인덱스 기능으로 인해, 프라이머리 키의 주소를 참조한다.
- 일반적으로 인덱스는 B-Tree 알고리즘이 사용된다.

# 8.3 B-Tree 인덱스
- Balanced Tree 의 약자이다.
- 데이터를 항상 정렬된 상태로 유지하며, 일반적인 용도에 적합한 알고리즘이다.
- 루트노드, 브랜치 노드, 리프 노드로 구성된다. 리프 노드엔 값과 참조값이 들어있으면 루트 노드와 브랜치 노드는 리프 노드를 찾기 위한 용도로 사용된다.
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
- 인덱스 키 추가는 밸런싱 비용때문에 비싸다.
    - 테이블에 레코드를 추가하는 비용이 1이라면,
    - 하나의 인덱스 변경에는 1.5 정도의 비용이 들어가며
    - 세 개의 인덱스를 가지고 있는 테이블을 변경하기 위해서는 5.5 정도의 비용이 들어간다고 예측한다.
    - 인덱스 변경 비용의 대부분은 디스크 IO 이다.
    - 프라이머리 키이거나 유니크 인덱스가 아닌 경우 체인지 버퍼를 이용해 인덱스 변경 작업을 지연시킬 수 있다.
- 인덱스 키 삭제는 삭제 마크만 해두고, 실제 삭제는 백그라운드에서 처리한다.
- 인덱스 키 변경은 삭제 후 추가하는 방식으로 이루어진다.
- Update 나 Delete 시 인덱스를 잠근 후 테이블을 잠그는 방식으로 실행되기 때문에, 적절한 레코드가 없다면 불필요하게 많을 레코드를 잠근다.
- B-Tree 인덱스 사용에 영향을 미치는 요소
    - 페이지 또는 블록은 디스크 IO 및 버퍼링의 최소 작업 단위이다.
    - 페이지의 사이즈는 innodb_page_size 시스템 변수로 설정이 된다.
    - B-Tree 의 노드도 페이지 단위로 저장되므로, 인덱스 키의 크기가 작다면 인덱스를 효율적으로 사용할 수 있다.
    - 마찬가지로 메모리를 효율적으로 사용할 수 있기 때문에 메모리에 캐시해둘 수 있는 레코드 건수도 증가한다.
    - 선택도 = 기수성 = 유니크한 값의 개수
    - 선택도가 높으면 (기수성이 크면) 인덱스를 효율적으로 사용할 수 있다.
    - 선택도가 좋지 않더라도 정렬이나 그루핑에 인덱스를 사용할 수 있으므로 적절히 인덱스를 설계해야한다.
    - 인덱스를 이용해 레코드를 읽는 것은 테이블에서 직접 레코드를 읽는 것의 4~5배 정도의 비용이 든다고 예측한다.
    - 따라서 전체 레코드의 20~25% 이상을 읽어야 한다면 테이블 풀스캔을 하게 된다.
- B-Tree 인덱스를 통한 데이터 읽기
    - 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 명확히 결정됐을 때 사용하는 방식이다.
        - 실행 계획에서 type 이 range 로 표시된다.
        - 가장 효율적이다.
        - 인덱스 만으로도 데이터를 가져올 수 있을 때 디스크 랜덤 IO를 발생시키지 않는 커버링 인덱스를 사용한다.
    - 인덱스 풀스캔은 인덱스를 처음부터 끝까지 모두 읽는 방식을 의미한다.
        - 테이블 풀스캔보다 인덱스 풀스캔이 저렴한데, 전체 데이터를 읽어야 하나, 쿼리를 인덱스에 있는 컬럼만으로 처리할 수 있을 때 사용한다.
        - 인덱스 레인지 스캔보다 빠르지는 않지만, 테이블 풀스캔보다는 효율적이다.
    - 루스 인덱스 스캔
        - MIN 또는 MAX 처럼 함수에 대한 최적화를 할 때 사용한다.
        - MIN 또는 MAX 연산에 필요하진 않은 인덱스는 건너뛰면서 읽는다.
    - 인덱스 스킵 스캔
        - 특정 조건을 추가해 레인지 스캔이 가능할 경우 사용한다.
        - A, B 칼럼에 인덱스가 있고, A의 선택도가 낮을 경우, 유니크한 A의 값을 쿼리에 추가해서 레인지 스캔으로 전환한다.
        - A 칼럼의 유니크한 개수가 적어야 하고, 커버링 인덱스일 때만 사용된다.
- 다중 칼럼 인덱스
    - 컬럼 순서대로 정렬된다. A, B 컬럼으로 인덱스가 잡혀있다면, B 컬럼의 정렬은 특정 A 컬럼 내에서만 유효하다.
    - 인덱스의 정렬 방향이 ASC, DESC 로 되어 있다면, 인덱스는 MySQL 8.0 부터 지원하는 내림차순 인덱스로만 해결할 수 있다.
- 인덱스의 정렬 방향
    - 인덱스를 오름차순으로 만들어도 역순으로 읽으면 내림차순 인덱스가 된다.
    - 역순 스캔은 인덱스 페이지의 구조 상 읽기 속도와 잠금에서 불리하다.
- B-Treee 인덱스의 가용성과 효율성
    - 인덱스에 설정된 컬럼은 작업 범위를 좁혀야 효율적이다.
    - 다음은 인덱스를 효율적으로 사용하지 못하는 케이스이다.
        - NOT EQUAL 로 비교된 경우
        - LIKE "%??"
        - 칼럼이 변형되어 비교된 경우
        - 조건에 NOT DETEMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
        - 데이터 타입이 서로 다른 비교
        - 콜레이션이 다른 경우
- 함수 기반 인덱스
    - 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축할 때 사용한다.
    - 가상 칼럼을 사용하거나, 함수를 이용할 수 있다.
    - 가상 칼럼을 사용하는 경우
        - 칼럼 정의에 AS 로 함수를 선언하고 VIRTUAL 키워드를 붙여준다.
        - 만들어진 가상 칼럼에 인덱스를 걸어준다.
        - 실제 테이블 구조가 변경된다.
    - 함수를 사용하는 경우
        - 인덱스를 정의할 때 함수를 적어줄 수 있다.
        - 조건절에 함수 기반 인덱스에 명시된 표현식이 정확하게 사용되어야 한다.
        - 테이블의 구조는 변경하지 않는다.
- 멀티 밸류 인덱스
    - JSON 필드에 인덱스를 걸 수 있다.
    - 반드시 다음 함수를 이용해서 검색해야 한다.
        - MEMBER OF
        - JSON_CONTAINS
        - JSON_OVERLAPS
- 클러스터링 인덱스
    - 클러스터링 인덱스는 프라이머리 키에 대하서만 적용된다.
    - 프라이머리 값이 비슷한 레코드끼리 물리적으로 묶어서 저장하는 것을 클러스터링 인덱스라고 한다.
    - 따라서 클러스터링 테이블은 거대한 인덱스라고 볼 수 있다.
    - 세컨더리 인덱스는 클러스터링 키를 참조한다.
        - 레코드의 실제 주소를 숨기기 위해 실제 주소를 클러스터링 인덱스로 추상화 한 것.
    - 장단점
        - 장점1: 세컨더리 인덱스로 PK 를 조회한 경우 커버링 인덱스가 된다.
        - 장점2: PK 로 조회할 때 성능이 좋다.
        - 단점1: 세컨더리 인덱스로 검색할 때 두번 검색해야함.
        - 단점2: PK 의 크기가 큰 경우 세컨더리 인덱스 크기도 커진다.
- 유니크 인덱스
    - 유니크 인덱스는 제약조건에 가깝다.
    - 유니크 인덱스에 NULL 값은 두개 이상 저장될 수 있다.
    - 유니크 인덱스는 읽어야할 개수를 줄여줄 뿐, 인덱스 구조 자체가 빠른 것은 아니다.
    - 하나의 값을 검색하는 경우, 유니크 인덱스와 세컨더리 인덱스는 실행 계획이 다르지만, 큰 차이는 없다.
    - 유니크 인덱스의 변경 작업은 반드시 중복체크를 해야하므로 메모리상 버퍼링이 불가능하다 -> 쓰기가 느리다.
    - 유니크 인덱스는 실행계획이나 파티션에 영향을 미친다.
    - 유니크하다고 성능상 이점이 있지는 않다.
- 외래키
    - 외래키 제약조건은 연관된 테이블을 체크해야 하기 때문에 잠금이 전파된다.
    - 부모 레코드 변경 중 자식 레코드를 변경하려는 경우 자식 레코드 변경이 대기하게 된다.
    - 자식 레코드 변경 중 부모 레코드를 변경하려는 경우 부모 레코드 변경이 대기하게 된다.
