# 2.1 들어가며
- 자바는 자동 메모리 관리 메커니즘 덕에 메모리 누수나 오버플로우 문제를 걱정하지 않아도 된다.
- 그러나 메모리 관리 이슈가 생겼을 때 JVM의 메모리 관리 방식을 이해하지 못하면 해결하기가 어렵다
- 따라서 JVM을 운영하면서 메모리 관련 이슈가 생겼을 때 문제를 해결하기 위해 JVM의 메모리 관리 방식에 대해 이해해야 한다.

# 2.2 런타임 데이터 영역
- JVM은 메모리를 목적과 데이터의 생명 주기에 따라 서로 다른 관리 방식을 채택하기 위해 몇 개의 데이터 영역으로 나누어 관리한다.
- 어떤 데이터는 프로그램의 실행과 동시에 만들어지며, 어떤 데이터는 사용자 스레드의 생성과 동시에 만들어지고 스레드 종료 시 사라진다.

## 2.2.1 프로그램 카운터
- JVM에서 PC는 바이트코드 줄 번호 표시기이다.
- 이 값에 따라 다음에 실행할 명령을 읽어들이고 실행한다.
- PC는 당연히 스레드별로 공유되지 않는다. 이를 스레드 프라이빗이라고 한다.
- PC에는 바이트코드 명령어의 주소가 기록된다.

## 2.2.2 JVM 스택
- JVM 스택에는 스택 프레임이 저장된다.
- 지역변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등 실행에 필요한 데이터가 저장된다.
- 지역변수 테이블에는 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다.
- 스레드 프라이빗한 메모리 공간이다.
- JVM 스택에서는 StackOverFlowError나 OOM Error를 던질 수 있다.

## 2.2.3 네이티브 메서드 스택
- 네이티브 메서드 스택은 네이티브 메서드 (C++ 로 작성된 코드 등) 을 실행할 때 사용하는 스택이다.
- JVM 스펙에는 네이티브 메서드 스택의 제한 조건에 대해 명시하지 않아 JVM 구현자가 자유롭게 구성할 수 있다.
- 네이티브 메서드 스택에서는 StackOverFlowError나 OOM Error를 던질 수 있다.
- 네이티브 메서드란?
    - JVM 언어가 운영체제나 다른 언어로 작성된 라이브러리와 통신하기 위한 메커니즘이다.
    - 네이티브 메서드와 통신하기 위한 인터페이스가 JNI 이다.

## 2.2.4 자바 힙
- 자바 힙은 모든 스레드가 공유하는 메모리 영역이다.
- 거의 모든 객체 인스턴스와 배열은 힙에 할당된다.
- 세대별 컬렉션 이론은 설계 방식일 뿐, JVM 스펙에는 세부 영역 구분에 관한 얘기는 없다.
- O(1)에 메모리 할당을 하기 위해 TLAB로 힙을 쪼갠다.
- 논리적으로 연속된 메모리 공간이어야 한다.
- OOM Error를 던질 수 있다.

## 2.2.5 메서드 영역
- 메서드 영역이란?
    - 메서드 영역은 JVM이 클래스 정보를 로드할 때 클래스 수준의 데이터를 저장하는 메모리 공간이다.
    - 클래스 이름, 상속관계, 메서드 이름, 리턴타입, 변수명, 문자열 리터럴, 상수, static 변수, final 상수, JIT 코드 캐시 등
- 스펙에선 메서드 영역도 힙의 한 부분으로 기술하지만, 힙과 구분하기 위해 논 힙으로 부르기도 한다.
- Java7 까지는 힙의 영구 세대에 메서드 영역에 있는 데이터를 저장했지만, 이후 버전부터는 네이티브 메모리를 사용한다. 이를 메타스페이스라고 한다.
- 문자열 상수와 정적 변수는 자바 힙으로, 나머지는 메타스페이스로 옮겼다.

## 2.2.6 런타임 상수 풀
- 런타임 상수 풀은 메서드 영역의 일부이다.
- 클래스 버전, 필드, 메서드, 인터페이스, 컴파일타임에 생성된 리터럴과 심볼 참조가 저장된다.
- 메서드 영역은 클래스 로딩 시 생기고, 런타임 상수 풀은 링크 중 심볼, 상수 참조를 해석해서 저장한다.
- 메서드 영역은 클래스 전체 정보를 저장하고, 상수 풀은 그 클래스의 리터럴과 심볼을 저장하는 포함관계이다.
- 런타임 상수 풀은 동적이다. 즉 실행중에도 런타임 상수 풀에 새로운 상수가 추가될 수 있다.

## 2.2.7 다이렉트 메모리
- JVM Runtime에 속하지 않으며 스펙에도 정의되지 않았지만 자주 쓰이는 메모리이다.
- JDK 1.4에서 NIO가 도입되면서 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 사용할 수 있다.
- DirectByteBuffer를 이용해 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 통신할 수 있는 기능이다.
- OOM이 발생할 수 있다.

# 2.3 핫스팟 가상 머신에서의 객체 들여다보기

## 2.3.1 객체 생성
- new 명령어를 만나면, 심벌 참조가 클래스인지 확인하고, 상수 풀에서 심벌 참조를 확인해 클래스를 로딩한다.
- 클래스 이름을 심볼이라고 하고, 이 심볼 데이터를 알기 위해선 메타 데이터를 참조해야 하기 때문에 런타임 심벌 참조 테이블을 확인해야한다.
- 해석한다는 것은 상수 풀에 있는 심벌 참조를 클래스 메타 데이터를 가리키는 직접 참조로 바꾼다는 뜻.
- 사용중인 메모리 영역이 얼마나 차있는지 나타내는 포인터 밀치기 방식이 필요한데, 메모리가 뒤섞여있으면 쉽지 않다. 따라서 스레드 전용 메모리 할당 공간인 TLAB를 쓴다.
- 메모리 할당 과정이 끝나면 객체 헤더 값 세팅 및 생성자 초기화 과정을 거친다.

## 2.3.2 객체의 메모리 레이아웃
- 객체 헤더
    - 마크 워드: 객체 해시코드, 세대 나이, 락 상태 플래그 등
    - 클래스 워드: 클래스 관련 메타데이터 포인터
    - 배열 길이
- 인스턴스 데이터
    - 실제 객체 값의 내용이 담긴다.
- 정렬 패딩

## 2.3.3 객체에 접근하기
- 스펙에서는 참조를 '객체를 가리키는 참조'라고만 정의했을 뿐, 힙의 정확한 위치를 알아내어 접근하는 구체적인 방법은 규정하지 않았다.
- 핸들 방식이란 객체의 참조를 매핑 테이블로 관리하는 방식으로, GC 등으로 인해 객체의 주소가 변경되었을 때 핸들 풀의 포인터 값만 바꾸면 되는 방식이다.
- 다이렉트 포인터 방식은 참조를 직접 객체 인스턴스 데이터에 저장하는 방식이다. 핫스팟이 주로 사용하는 방식이다.

# 2.4 실전: OutOfMemoryError 예외
- JVM 설정을 바꿔보면서 테스트하는 내용이므로 정리는 생략