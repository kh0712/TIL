P93~103), P111~P116 (3.4.4 이전
# 3.1 들어가며
- 가비지 컬렉션은 어떤 메모리를, 언제, 어떻게 회수해야하는가를 해결해야 한다.
- 메모리 오버플로와 누수 문제를 해결하고 동시성을 높이기 위해선 가비지 컬렉터 기술을 이해하고 있어야 한다.
- 자바 힙과 메서드 영역은 동적으로 메모리 요구량이 변할 수 있기 때문에, 얼마만큼의 메모리가 언제 생성될 지는 런타임에만 알 수 있다.

# 3.2 대상이 죽었는가?
- 대상이 죽었는지 판별하는 알고리즘을 소개한다.

## 3.2.1 참조 카운팅 알고리즘
- 어떤 객체가 다른 객체를 참조할 때 참조되는 객체에 참조 카운터를 증가시키고, 참조를 해제할 때 참조 카운터를 하나 감소시킨다.
- 그러나 참조 카운팅 알고리즘은 순환 참조되는 객체를 수집하지 못한다.
    - 근데 왜 다른 언어에선 계속 사용될까?
    - GC 구현이 단순하고, 빠르다.
    - Python 에서는 별도의 cycle collector를 돌린다.
    - Rust는 강한 참조의 경우 메모리 누수가 생기지만, Weak 참조로 이를 방지할 수 있다.

## 3.2.2 도달 가능성 분석 알고리즘
- GC 루트라고 하는, 항상 도달할 수 있는, 시초 격의 객체 루트로부터 GC 대상 객체를 도달할 수 있는지 탐색한다.
    - 가상 머신 스택에서 참조하는 객체 (현재 실행 중인 메서드의 매개 변수나 지역 변수 등)
    - 클래스가 정적 필드로 참조하는 객체
    - 메서드 영역에서 상수로 참조되는 객체
    - 자바 가상 머신 내부에서 쓰이는 참조
    - 동기화 락으로 잠겨 있는 객체
    - 컬렉터나 회수 메모리 영역에 따라 다른 객체들도 임의의 객체를 추가할 수도 있다. 
- 최신 가비지 컬렉터들은 부분 컬렉션을 지원하고, GC 루트가 너무 많아지지 않도록 다양한 최적화를 적용한다.

## 3.2.3 다시 참조 이야기로
- 참조의 전통적인 의미: 참조 타입 데이터에 저장된 값이 다른 메모리 조각의 시작 주소를 뜻하는 것
- JDK 1.2 이상의 참조: 강한 참조, 부드러운 참조, 약한 참조, 유령 참조, 파이널 참조
    - 부드러운 참조 : 참조는 하지만 필수는 아니라서 회수될 수 있음
    - 약한 참조: 다음 번 가비지 컬렉션까지만 살아있다.
    - 유령 참조: 객체 수명에 영향을 주지 않는 참조. 객체가 회수될 때 알림을 받기 위해서
    - 파이널 참조: finalize 메서드를 구현한 객체를 JVM 내부에서 참조하기 위한 참조.

## 3.2.4 살았나 죽었나?
- 도달 불가능이라고 해도 두번의 표시 과정을 거쳐야 한다.
- 도달 불가능이어도 finalize() 메서드 호출을 해야 한다면 F Queue에 적재되고, 종료자 스레드가 F Queue 에 있는 객체들의 finalize 메서드를 호출한다.
- finalize로 참조를 만들어 부활할 수 있으나, finalize 메서드가 호출되는 것은 딱 한번 뿐이기 때문에 다시 GC 대상이 되었을 때 소생하지는 못한다.
- finalize는 쓰지 말자.

## 3.2.5 메서드 영역 회수하기
- 메서드 영역에서는 상수와 클래스를 회수할 수 있다.
- 문자열 상수를 지우거나 다른 클래스, 메서드, 필드의 심벌 참조도 회수할 수 있다.
- 클래스를 회수하는 조건은 까다롭다. 그러나 리플렉션, 동적 프락시, CGLib과 같은 바이트코드를 사용하는 프레임워크를 사용할 때는 JVM이 타입 언로딩을 지원해야한다.

# 3.3 가비지 컬렉션 알고리즘

## 3.3.1 세대 단위 컬렉션 이론
- 세대 단위 컬렉션 이론은 설계 원칙일 뿐, GC를 만드는 방법 그 자체가 아니다.
- 약한 세대 가설
    - 대다수 객체는 일찍 죽는다.
- 강한 세대 가설
    - 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
- 세대 간 참조 가설
    - 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.
    - 신세대 - 구세대간 참조가 있어도 신세대 객체는 구세대로 가기 때문에 세대간 참조는 점점 더 적어진다.
- 신세대에서만 GC를 하고 싶어도 신세대에 속하지만 구세대에서 참조중인 객체도 있을 수 있기 때문에 구세대 전체를 탐색해야할 수도 있다. 따라서 효율을 높이는 방법을 찾아야한다. 이를 위해 세대 간 참조 가설을 사용한다.
- 신세대에 기억 집합이라는 전역 데이터 구조를 두고, 구세대의 어느 영역에서 신세대로의 참조가 있었는 지를 기록한다.

## 3.3.2 마크-스윕 알고리즘
- 회수할 객체들을 표시하고, 표시된 객체들을 쓸어담는 방식이다.
- 대다수 객체가 회수 대상이면 효율이 떨어진다.
- 메모리 파편화가 심해진다.

## 3.3.3 마크-카피 알고리즘
- 가용 메모리를 똑같은 두 영역으로 나눠서 한 영역을 GC 돌려서 살아남은 객체를 다른 메모리 영역으로 복사하고, 기존 영역은 비운다.
- 메모리를 절반밖에 쓰지 못하기 때문에 메모리 효율이 나쁘다.
- 그러나 대다수 객체는 살아남지 못하기 때문에 1:1로 분할할 필요가 없고, 8:1 정도의 비율로 나눠 메모리를 90퍼센트 활용한다.
- 10퍼센트의 공간이 가득 차면 구세대로 승격한다.

## 3.3.4 마크-컴팩트 알고리즘
- 마크-스윕 알고리즘에서 메모리 컴팩션이 추가된 알고리즘이다.
- 메모리 사용 효율이 좋고, 단편화도 생기지 않지만 STW가 길어진다.
- 객체를 이동시키면 회수 작업이 복잡해지고, 이동시키지 않으면 할당 작업이 복잡해진다.
- STW를 기준으로 삼냐, 처리량을 기준으로 삼냐에 따라서도 다르다.
- 마크 스윕을 쓰다가 파편화가 심해지면 마크 컴팩트를 사용할 수 있다.

# 3.4 핫스팟 알고리즘 상세 구현

## 3.4.1 루트 노드 열거
- 루트 노드 열거란 GC 루트 집합으로부터 참조 체인을 찾는 작업이다.
- 루트 노드를 열거하기 위해서는 Stop the World를 피할 수 없다. -> 탐색 중 참조가 생기거나 끊어질 수 있기 때문
- 참조 체인을 구성하는 작업은 반드시 STW가 필요하지만, 마킹 과정은 사용자 스레드와 동시에 할 수도 있다.
- CMS, G1, ZGC도 반드시 일시 정지를 해야한다.
- "현재 주류 가상 머신들은 '정확한 카비지 컬렉션'을 사용한다. 따라서 사용자 스레드가 정지한 후 실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다. 그 대신 가상머신이 객체 참조가 저장된 위치를 직접 알아낼 방법이 있어야 한다
    - 어디에 어떤 참조가 있는지 알수는 있는데 그걸 oopmap 처럼 저장할 공간이 필요하다는 말
- OOP Map은 로컬 변수 어떤 슬롯이 참조인지 비트맵 형태로 기록한다.

## 3.4.2 안전 지점
- 비용 문제로 핫스팟은 모든 명령어에 OopMap을 생성하는 대신, SafePoint라고 하는 특정 위치에만 기록한다.
- 안전 지점(Safe Point) -> 지금 멈춰도 프로그램이 이상해지지 않는 시점
    - 안전 지점이 아니면 중간 계산중이거나, 객체 참조를 레지스터에만 들고 있거나 할 수 있는 등 문제가 생길 수 있다.
- 스레드는 실행 중에 GC 플래그를 검사하다가 GC 플래그가 true이면 가장 가까운 안전 지점에 멈춘다.
- 안전지점, 힙 메모리를 소비하는 곳에 폴링 메모리가 추가된다. 핫스팟은 메모리 보호 트랩으로 폴링을 효율적으로 구현한다.
- 안전 지점의 종류
    - 메서드 호출, 메서드 반환, 예외 처리 시점, 루프 백엣지, JNI 호출 전후
    - 이 시점에서는 객체 참조 정보가 OopMap 에 정리되어 있기 때문에 GC를 돌려도 안전하다.

## 3.4.3 안전 지역
- 안전 지역이랑 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장하는 곳이다.
- 안전 지역을 벗어나기 위해선 GC가 완료되었는지 체크해야한다.

## 3.4.4 기억 집합과 카드 테이블
- 기억 집합은 비회수 영역에서 회수 영역을 가리키는 포인터를 기록하는 추상 데이터 구조이다.
- 비회수 영역에 있는 모든 세대간 참조들을 다 기록할 수 있지만, 비효율적이기 때문에 정밀도를 낮춰서 특정 메모리 블록에 있는지 없는지만 기록한다.
- 이를 카드 정밀도라고 하고, 카드 정밀도로 기억 집합을 구현한 것을 카드 테이블이라고 한다.
    - CARD_TABLE[this address >> 9] = 1; 
    - 카드 하나의 크기를 2^9 바이트로 정한 예시
    - 1로 세팅하면 참조하는 요소가 있다. 즉 더럽혀졌다라고 한다.
- 카드 테이블에서 더럽혀지 원소만 확인하여 GC를 수행할 수 있다.

## 3.4.5 쓰기 장벽
- 쓰기 장벽이란 카드 테이블 갱신을 위해 객체의 필드에 새로운 참조 값을 쓰기 전/후에 실행되는 작은 코드 조각이다.
- JIT 컴파일러가 자동으로 삽입한다.
- 참조 타입 대입 시 끼어드는 AOP와 같다.
- 카드 테이블 CPU 캐시 거짓공유 문제를 해결하기 위해선 dirty 상태가 아닐 때만 쓰도록 한다.
    - 카드 테이블은 정밀도를 낮춘 flag 이기 때문에 하나의 캐시 라인 크기가 수십 바이트더라도, 캐시 라인에 저장된 카드 테이블이 가리키는 객체 데이터는 수십 킬로바이트정도로 1000 배 차이날 수 있다.

## 3.4.6 동시 접근 가능성 분석
- 객체 그래프를 생성하고 (루트 노드 열거), 스냅샷 상태에서 객체 그래프를 탐색해야 하는 이유
    - 객체 노드를 삼색 표시 기법으로 객체 그래프를 탐색한다.
    - 검은색 : GC가 방문한 적이 있고, 이 객체가 가리키는 모든 참조를 스캔했다. -> 생존하는 케이스, 다시 스캔하지 않아야함.
    - 회색: GC가 방문한 적이 있으나, 이 객체가 가리키는 참조 중 스캔을 완료하지 않은 객체가 존재한다.
    - 흰색: GC가 방문한적 없는 객체
    - 회색은 스캔 큐에 있기 때문에 다시 넣지 않아도 된다. 그래서 삼색 표시 기법인 것.
- GC 중 사용자 스레드에 의해 객체 사라짐 문제 케이스 두가지가 모두 만족되어야 함.
    - 검은색 객체에 흰색 객체로의 참조를 추가
        - 참조가 추가된 검은색 객체를 따로 기록하고 다시 검은색 객체르 대상으로 스캔한다.
    - 회색 객체에서 흰색 객체로의 직간접적인 참조를 삭제
        - 해결 방법: 회색 객체가 흰색 객체로의 참조를 끊으려하면 그 사실을 기록하고, 기록된 회색 객체를 다시 스캔한다.
     - 참조가 끊겼는데 검은색 객체가 참조하면 회수되지 말아야할 위험한 상황이 생긴다.
